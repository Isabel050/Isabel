---
title: "ThreatNet Israel"
author: "Meusel et al."
output:
  flexdashboard::flex_dashboard:
    theme: 
      version: 4
      bootswatch: minty # We can set color themes!
      #Also check out help on bs_themer
    orientation: rows
    source_code: embed
# If we Output HTML, this allows Latex for the Documentation:  
# mathjax: "http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
runtime: shiny
---


```{r setup, include=FALSE}
library(ggplot2)
library(tidyverse)
library(reshape2)
require(deSolve)
library(shiny)
library(plotly)
library(plyr)
library(flexdashboard)
library(i18n) #Translations

# Debug: getwd()
# if (interactive()){setwd("Insert Directory here")}

# bslib::bs_themer() # <- This lets you look at themes and pick.

# Not yet working, need to implement.
#i18n <- Translator$new(automatic=TRUE)
#i18n$set_translation_language("en")
  
#We need the scenarios run in Montecarlo, unless that is done already.
if((file.exists("Master_Frame_a.csv")&file.exists("Master_Frame_Full.csv"))){ScenariosRun=TRUE} else {ScenariosRun=FALSE}
#Manual rerun instead: ScenariosRun=FALSE
source("Costs.r", local=TRUE)
source("Montecarlo.r", local=TRUE) #Note: Uses an output from costs
source("SEIR.r", local=TRUE)

# Function Definitions

#Import Data from xslx Generated earlier:
Master_Frame_a <- read.csv("Master_Frame_a.csv")
Master_Frame_a$X <- NULL
MonteCarloData <-Master_Frame_a %>%
  pivot_longer(!c("Case","Cases_continuous"), names_to = "Coverage", values_to = "Cumulative_probability") 
MonteCarloData <- 
  separate_wider_delim(MonteCarloData, "Coverage", "_",
                       names= c(NA, "HospPCT","DetectThreshold",NA))

# Master_Frame_Full <- read.csv("Master_Frame_Full.csv") # Adds 10-15 seconds to loading!
Master_Frame_Full$X <- NULL
Master_Frame_Full <- Master_Frame_Full %>%
  pivot_longer(!c("Case","Cases_continuous"), names_to = "Coverage", values_to = "Cumulative_probability") %>% separate_wider_delim("Coverage", "_",
                       names= c(NA, "HospPCT","DetectThreshold",NA))


map=data.frame(HospPCT=Coverage_rates,Coverage_names)
MonteCarloData <- merge(MonteCarloData,map)


model_df<-data.frame(times)
  for(i in 1:length(Disease_Cases)){
    model <- ode(initial_state, times, SEIR, Disease_Cases[[i]]$params)
    matplot(model, type="l", lty=1, main=paste("SEIR model",Disease_Cases[[i]]$name), xlab="Time")
    legend <- colnames(model)[2:6]
    model_df<-cbind(model_df,data.frame(model))
  }

  
  #Get distinct names per case:
  colnames(model_df) <- make.names(colnames(model_df), unique = TRUE)

  #Group into cumulative infections
  model_df_aggregated<-data.frame(times)
  for(i in 1:length(Disease_Cases)){
    case = i-1
    if(case==0){
      model_df_aggregated<-cbind(model_df_aggregated,model_df$I+model_df$R)
    }
    else{
      model_df_aggregated<-cbind(model_df_aggregated,
                                 get(paste0('I.',case), envir=as.environment(model_df)) +
                                   get(paste0('R.',case), envir=as.environment(model_df))
      )
    }
  }
  names(model_df_aggregated) <- c("time",Disease_names)
  colnames(model_df_aggregated)[1]<-c("Days")
  
  #Restructure for ggplot
  model_df_agg_longer <- #For testing
    model_df_aggregated %>%
    pivot_longer(!Days, names_to = "Pathogen", values_to = "Cases_TTD")
  
  #model_df_aggregated is the disease number of cases by day
  #MonteCarloData is the detection time by number of cases in hospitals for detection
  
  #We need a new data frame with the levels from both DF.
  
  # MonteCarloData has HospPCT and DetectThreshold, plus merge variable Cases_continuous
  # model_df_aggregated has Days and Cases per disease.
  # Discretize model_df_aggregated case counts by rounding down:
  model_df_aggregated_discrete <- data.frame(lapply(model_df_aggregated,floor))
  #I only want the first day that there are X cases.
  All_disease_mapping_table <- 0
  #Disease Names with spaces, etc. get mangled, so:
  corr_Disease_names = gsub(" ",".",gsub("-",".",Disease_names))
  
  # Add disease columns to MonteCarloData.
  for (name in corr_Disease_names){ # Which are columns in model_df_aggregated_discrete
    #print(name) }
    temp_table <- model_df_aggregated_discrete[,c('Days',name)]
    names(temp_table)<-c('Day','Cases_continuous')
    temp_table$Cases_continuous = temp_table$Cases_continuous
    temp_table$Disease = name
    if (length(All_disease_mapping_table)==1){
      All_disease_mapping_table <- temp_table
    } else {All_disease_mapping_table <- rbind(All_disease_mapping_table, temp_table)}

  # But we need to offset by the delay!
  #Do this within the graphing, or it needs a reactive DF, which is expensive!
  
    #Include only the first day with that many cases.
    temp_2 <- All_disease_mapping_table %>% group_by(Cases_continuous, Disease) %>% filter(rank(Cases_continuous,ties.method="first")==1)
    temp_2 <- data.frame(temp_2)
    All_disease_mapping_table <- temp_2
    

    #Set detection threshold for graphs
    Detect_Threshold_ForDate <- 0.95 # 95% Chance of Detection

Case_Count_at_Detection <- data.frame(MonteCarloData %>% group_by(DetectThreshold, HospPCT) %>% arrange(as.numeric(HospPCT)) %>%
filter(Cumulative_probability>=Detect_Threshold_ForDate) %>%
slice_min(Cumulative_probability,with_ties=FALSE))

Case_Count_at_Detection_AllValues <- data.frame(Master_Frame_Full %>% group_by(DetectThreshold, HospPCT) %>% arrange(as.numeric(HospPCT)) %>%
  filter(Cumulative_probability>=Detect_Threshold_ForDate) %>%
  slice_min(Cumulative_probability,with_ties=FALSE))
    
Case_Count_at_Detection_AllValues <- merge(Case_Count_at_Detection_AllValues,Full_Cost_Map)

if (FALSE) {"
Data Manifest:

- MonteCarloData is the results of the Monte-carlo Simulation for specified percentages of hospitals (Previously named Master_Frame_a. Has Coverage_names: Titles for 'Top N' )
- Master_Frame_Full is the same, for all percentages, to use for per-hospital selection and the cost function.
- Columns: HospPCT, Cases_continuous, DetectThreshold, Cumulative_probability
- Note: HospPCT can be mapped to Top N with Full_Cost_Map (This is done for cost curves. This will not match if we select arbitrary hospitals.)

- Hospital_visitors is the number of visitors per hospital per year, and percentages for 2021, which is the year used. (This is used for the cost mapping.)

- Full_Cost_Map is the number of 'Top N' hospitals, with corresponding cost / HospPCT.

- model_df is the raw SEIR model outputs per disease.
- model_df_aggregated_discrete is the cumulative number of clinical cases (I+R) per disease, discretized to whole numbers of cases.
Columns: Days, [Each Pathogen Name], Cases_TTD.
This is pivoted to have pathogens as one column in below code.


"}
save.image(file='ShinyApp_SetupRun.RData')
} else {load('ShinyApp_SetupRun.RData')} #If not slow, just load it.

#Note: Ideally, the below code should not have any side effects. It does, so the order matters, as some chunks rely on the changes made in graphs run earlier.
#TODO: Fix this. (Low priority)
```



Sidebar {.sidebar}
=====================================

### Inputs for Model

```{r}
   selectInput(inputId = "Disease_Scenario",
               label = "Disease Scenario",
               choices = Disease_names,
               selected = c("SARS-CoV-2","Seasonal Flu","Pandemic 1918 Flu","SARS-CoV-2 Omicron"),
               multiple= TRUE
              )
   selectInput(inputId = "Coverage",
               label = "Hospitals participating in Threatnet",
               choices = Coverage_names,
               selected = 2)
   sliderInput(inputId = "Threshold",
               label = "Detections needed to confirm disease",
               min = 1,
               max = 5,
               value = 1,
               step=2,
               ticks=FALSE)
   sliderInput(inputId = "Delay",
               label = "Days needed to confirm result",
               min = 1,
               max = 5,
               value = 1,
               step=2,
               ticks=FALSE)
      radioButtons(inputId = "HospitalizationLag",
               label = "Time from infection until hospitalization",
               choiceNames = "2 Weeks",
               choiceValues = 14 
               ) #This is hardcoded below because it breaks otherwise. (What is the input type, maybe?)
      selectInput(inputId = "HospitalList",
               label = "List of Hospitals (Unused)",
               choices = Hospital_visitors$Hospital,
               selected = 1,
               multiple= TRUE
              )
```

Model Outputs
=======================================================================

Row
-----------------------------------------------------------------------

### Detection probability by number of hospitalized cases

```{r}

#Need to sort so that the factors are in alphabetical order, to match the graph.

# This doesn't HELP. ARGH!
#map=data.frame(num=as.numeric(MonteCarloData$HospPCT),HospPCT=MonteCarloData$HospPCT,Cover=factor(MonteCarloData$Coverage_names)) %>% distinct() %>% arrange(num)
#MonteCarloData=merge(MonteCarloData,map)

renderPlot({
  
    p2 <- ggplot() + 
      geom_point(data=MonteCarloData %>% filter(DetectThreshold==input$Threshold),
                 aes(y=Cumulative_probability, x=Cases_continuous, color = Coverage_names),
                 size=1) +
      labs(x="Infections", y="Cumulative probability")+
      xlim(0,100)+
      geom_smooth(data=MonteCarloData %>% 
                    filter(DetectThreshold==input$Threshold),
                  formula=y ~ s(x, bs = "cs"), 
                              aes(y=Cumulative_probability, 
                                  x=Cases_continuous, group = Coverage_names), 
                              method="gam",color="black",se=FALSE, 
                              linetype=5, linewidth=1.3)
     
    p2 + theme_gray() +
      theme(axis.title.x = element_text(face="bold", size=15))+
      theme(axis.title.y = element_text(face="bold", size=15))+
      theme(title= element_text(face="bold", size=20))+
      theme(legend.position = c(0.8, 0.2)) +
      #scale_color_discrete(labels=Coverage_names)+
      #These represent the 50, 80, and 95% probability of detection.
      geom_hline(yintercept=0.5, linetype=5, color = "gray40")+
      geom_hline(yintercept=0.8, linetype=5, color = "gray20")+
      geom_hline(yintercept=0.95, linetype=5, color = "gray0")
  })
```

### Disease Outcomes

```{r Disease Outcomes}
  #For diseases, we needed to run the models (above,) rearrange (above,) and plot them.
# We probably don't want this graph.

# This could be inflated by the percentage non-hospitalized - which varies per disease! (But only reflected in this graph.)
  
  p3 <- renderPlot({ggplot() +
      geom_line(data=model_df_agg_longer %>% filter(Pathogen %in% input$Disease_Scenario),
                aes(y=Cases_TTD, x=Days, color=Pathogen), linewidth=1.1,linetype=1)+
      labs(x="Days", y="Infections")+
      xlim(0,70)+
      ylim(0,400)+
      ggtitle("SEIR Model") + theme_gray()+
      theme(axis.title.x = element_text(face="bold", size=15))+
      theme(axis.title.y = element_text(face="bold", size=15))+
      theme(title= element_text(face="bold", size=20))
  })
  p3
```

Row
-----------------------------------------------------------------------
### Detection Probability by Disease

```{r Detection Probability by Disease}

# At this point, we need to use colors EITHER to represent HospPCT *OR* Disease.
Disease_num <-reactive(match(input$Disease_Scenario[[1]]))

MonteCarloData$HospPCT=factor(MonteCarloData$HospPCT,levels=sort(unique(as.numeric(as.character(MonteCarloData$HospPCT)))))

renderPlot({
  print(input$HospitalizationLag)
  # We now need to add input$Delay and input$HospitalizationLag to the All_disease_mapping_table!
  All_disease_mapping_table$Day = All_disease_mapping_table$Day + input$Delay + 14
  #Also add a zero point, to fix the graph?
  Zero_points = data.frame(Disease=gsub(" ",".",gsub("-",".",Disease_names)))
  Zero_points$Day=0
  Zero_points$Cases_continuous=0
  All_disease_mapping_table=rbind(All_disease_mapping_table,Zero_points)
  #print(All_disease_mapping_table[which(All_disease_mapping_table$Cases_continuous<2),]) 
  
  ggplot() + 
        geom_point(data=inner_join(MonteCarloData,
                                   All_disease_mapping_table 
                                   %>% filter(Disease==gsub(" ",".",gsub("-",".",input$Disease_Scenario[[1]]))))
                   %>% filter(DetectThreshold==input$Threshold),
                   aes(y=Cumulative_probability, x=Day, color=HospPCT, group = as.numeric(HospPCT)), size=1) +
        labs(x="Day", y="Cumulative probability")+
        xlim(0,100)+
        geom_smooth(data=inner_join(MonteCarloData,
                                    All_disease_mapping_table
                                    %>% filter(Disease==gsub(" ",".",gsub("-",".",input$Disease_Scenario[[1]])))) 
                    %>% filter(DetectThreshold==input$Threshold),
                    formula=y ~ s(x, bs = "cs"), 
                    aes(y=Cumulative_probability, 
                        x=Day, group = HospPCT),
                    method="gam",color="black")+
        ggtitle(input$Disease_Scenario[[1]])
    })

```

### Cost versus Infections Graph

```{r Cost versus Infections Graph}

HospPCT=unique(as.character(MonteCarloData$HospPCT))

# Done above in All_disease_mapping_table
# But this table doesn't related to the disease, it's case counts only...
# We want to graph day at first detection versus cost.


# It can end up picking the stochastically lowest case count, which can make fewer hospitals graph as (slightly) more effective
# MasterFrame_Averaged <- data.frame(Master_Frame_Full %>% group_by(Case,HospPCT,DetectThreshold,Cases_continuous) %>%
#    dplyr::summarize(Cumulative_probability = mean(Cumulative_probability, na.rm=TRUE)))
#Doesn't help - still have ties... :(

#Moved to above

# Test_MFF <- data.frame(Master_Frame_Full %>% group_by(Case,HospPCT,DetectThreshold,Cases_continuous) %>%
#     dplyr::summarize(Cumulative_probability = mean(Cumulative_probability, na.rm=TRUE)))
# 
# Case_CaDAV_Test <- data.frame(Test_MFF %>% group_by(DetectThreshold, HospPCT) %>% arrange(as.numeric(HospPCT)) %>%
#   filter(Cumulative_probability>=Detect_Threshold_ForDate) %>%
#   slice_min(Cumulative_probability,with_ties=FALSE))

#Costs:
#Just put the algebra in manually:
# HospPCT=Now From Data Frame, pulled above.
# Set in the Montecarlo.R script
#n_Hosp was set in the MonteCarlo Script.
#print(slice_head(Case_Count_at_Detection,n=2))

HospPCT = as.character(sort(as.numeric(HospPCT)))
map=data.frame(HospPCT,n_Hosp)
#print(n_Hosp)
#print(map)
Case_Count_at_Detection=merge(Case_Count_at_Detection,map)

Overall_10y_Cost <- Cost(n_Hosp)

Full_Cost_map=data.frame(n_Hosp,Overall_10y_Cost)
Case_Count_at_Detection<- merge(Case_Count_at_Detection,Full_Cost_map)

#Problem:
# Case_Count_at_Detection_AllValues$n_Hosp = as.numeric(Case_Count_at_Detection_AllValues$HospPCT)
# This wasn't what I want. The costs are for this number of hospitals, but I was accidentally treating it as the percentage. Whoops.
# Iinstead needed to find the minimum number of hospitals to get a given coverage level...
# (This is trivially the N largest.)
# Fixed - Then Added Full Cost Map to MonteCarlo Script.

#print(Case_Count_at_Detection)
renderPlot({
  ggplot()+ geom_point(data=Case_Count_at_Detection_AllValues,
                       aes(y=Overall_10y_Cost, x=Cases_continuous, color=DetectThreshold), size=1) +
    labs(x="Hospitalized Cases At Detection", y="10-year Discounted Costs")+
    geom_line(data=Case_Count_at_Detection_AllValues,
                aes(y=Overall_10y_Cost, x=Cases_continuous, group=DetectThreshold, color=DetectThreshold) )+
        scale_y_continuous(labels=scales::dollar_format(scale=0.000001, suffix="m",
                                                    n.breaks=4))+
    xlim(1000,0) + coord_cartesian(xlim=c(255, 0)) +
    scale_x_continuous(expand = expansion(add = 0, mult=0), n.breaks=6) +
    ggtitle(paste("Costs and Number of Hospitalized Cases at First Detection with", scales::percent(Detect_Threshold_ForDate), "probability"))+
annotate("text",x=190, xmax=240, y=350000000,label="Note that due to stochastic simulation, some noise exists")
    # ggplot()+ geom_point(data=Case_Count_at_Detection,
    #                    aes(y=Overall_10y_Cost, x=Cases_continuous, color=DetectThreshold), size=1) +
    # labs(x="Cases At Detection", y="10-year Discounted Costs")+
    # geom_line(data=Case_Count_at_Detection,
    #             aes(y=Overall_10y_Cost, x=Cases_continuous, group=DetectThreshold, color=DetectThreshold)
    #             )+
    #     scale_y_continuous(labels=scales::dollar_format(scale=0.000001, suffix="m",
    #                                                 n.breaks=4))+
    # xlim(1000,0)+
    # ggtitle(paste("Costs and Number of Hospitalized Cases at First Detection with", scales::percent(Detect_Threshold_ForDate), "probability"))
  })


# Partial_Graph = ggplot()+ geom_point(data=Case_Count_at_Detection,
#                        aes(y=Overall_10y_Cost, x=Cases_continuous, color=DetectThreshold), size=1) +
#     labs(x="Cases At Detection", y="10-year Discounted Costs")+
#     geom_line(data=Case_Count_at_Detection,
#                 aes(y=Overall_10y_Cost, x=Cases_continuous, group=DetectThreshold, color=DetectThreshold)
#                 )+
#         scale_y_continuous(labels=scales::dollar_format(scale=0.000001, suffix="m",
#                                                     n.breaks=4))+
#     xlim(1000,0)+
#     ggtitle(paste("Costs and Number of Hospitalized Cases at First Detection with", scales::percent(Detect_Threshold_ForDate), "probability"))
# Partial_Graph

```

More Graphs! (That don't work yet...)
=======================================================================
Row
-----------------------------------------------------------------------
### Detection Probability by Disease

```{r Detection Probability by Disease 2}

# Continuing From Detection Probability by Disease, do by Hospital Coverage

renderPlot({
  # We now need to add input$Delay and Hospitalization Lag to the All_disease_mapping_table!
  All_disease_mapping_table$Day = All_disease_mapping_table$Day + input$Delay + 14
  #All_disease_mapping_table$Day = All_disease_mapping_table$Day + 15
  #Also add a zero point, to fix the graph?
  Zero_points = data.frame(Disease=gsub(" ",".",gsub("-",".",Disease_names)))
  Zero_points$Day=0
  Zero_points$Cases_continuous=0
  All_disease_mapping_table=rbind(All_disease_mapping_table,Zero_points)
  #print(All_disease_mapping_table[which(All_disease_mapping_table$Cases_continuous<2),]) 
  # print(input$Coverage)
  # gsub(" ",".",gsub("-",".",input$Disease_Scenario[[1]]))
  Coverage_Selected = as.character(Coverage_rates[match(input$Coverage,Coverage_names)])
  Coverage_name_Selected = input$Coverage
  ggplot(data=inner_join(
            MonteCarloData%>% filter(HospPCT==Coverage_Selected)
            %>% filter(DetectThreshold==input$Threshold),
            All_disease_mapping_table  
            %>% filter(Disease!="MERS"), # Too few points, which breaks plotting stat_smooth!
            relationship = "many-to-many")) + 
        geom_point(
          aes(y=Cumulative_probability, x=Day, 
              color=Disease, group = as.numeric(HospPCT)), size=1) +
        labs(x="Day", y="Cumulative probability")+
        #xlim(0,100)+
    # ggplot() +  #For debugging  
    stat_smooth(formula=y ~ s(x, bs = "cs"),
          aes(y=Cumulative_probability,
              x=Day, group = Disease),
          method="gam", color="black")+
        ggtitle(paste("Detection by Disease for", Coverage_name_Selected))
    })

```

### Cases at Detection time + Delay by Cost
```{r}
#Re-create this, don't reuse version from other graph.
Case_Count_at_Detection_AllValues <- data.frame(Master_Frame_Full %>% group_by(DetectThreshold, HospPCT) %>% arrange(as.numeric(HospPCT)) %>%
  filter(Cumulative_probability>=Detect_Threshold_ForDate) %>%
  slice_min(Cumulative_probability,with_ties=FALSE))

Case_Count_at_Detection_AllValues <- merge(Case_Count_at_Detection_AllValues,Full_Cost_Map)

# Need to map to diseases. I want a table of disease cases on day t+delay+14.

renderPlot({
  model_df_agg_longer_offset = model_df_agg_longer
  model_df_agg_longer_offset$Days = model_df_agg_longer_offset$Days + input$Delay + 14
  colnames(model_df_agg_longer_offset)[3] <- "Cases_T_plus_n"
  
  Disease_delay_casecount = merge(model_df_agg_longer,model_df_agg_longer_offset)

  # Not working...
  Disease_Picked = input$Disease_Scenario[[1]] #gsub(" ",".",gsub("-",".",input$Disease_Scenario[[1]]))
  Coverage_Selected = input$Coverage
  #Disease_Picked = "SARS"
  #Coverage_Selected= "15"
    
  ggplot() + 
    geom_point(data=inner_join(
                 Case_Count_at_Detection_AllValues,
                  Disease_delay_casecount %>% filter(Pathogen==
                                                       Disease_Picked),
                  join_by(closest(Cases_continuous>=Cases_TTD))
                 ),
               aes(y=Overall_10y_Cost, x=Cases_T_plus_n, 
                   color=DetectThreshold), size=1) +
    labs(x="Total Cases At Detection in Hospitals", y="10-year Discounted System Costs")+
    geom_line(data=inner_join(
                 Case_Count_at_Detection_AllValues,
                  Disease_delay_casecount %>% filter(Pathogen==Disease_Picked),
                  join_by(closest(Cases_continuous>=Cases_TTD))
                 ),
              aes(y=Overall_10y_Cost, x=Cases_T_plus_n,
                  group=DetectThreshold, color=DetectThreshold) )+
    scale_y_continuous(labels=scales::dollar_format(scale=0.000001, 
                                                    suffix="m", n.breaks=4))+
    xlim(1000,0) + coord_cartesian(xlim=c(255, 0)) +
    scale_x_continuous(expand = expansion(add = 0, mult=0), n.breaks=6) +
    ggtitle(paste("Costs and Number of Hospitalized Cases at First Detection with", scales::percent(Detect_Threshold_ForDate), "probability"))
  
    # ggplot()+ geom_point(data=Case_Count_at_Detection,
    #                    aes(y=Overall_10y_Cost, x=Cases_continuous, color=DetectThreshold), size=1) +
    # labs(x="Cases At Detection", y="10-year Discounted Costs")+
    # geom_line(data=Case_Count_at_Detection,
    #             aes(y=Overall_10y_Cost, x=Cases_continuous, group=DetectThreshold, color=DetectThreshold)
    #             )+
    #     scale_y_continuous(labels=scales::dollar_format(scale=0.000001, suffix="m",
    #                                                 n.breaks=4))+
    # xlim(1000,0)+
    # ggtitle(paste("Costs and Number of Hospitalized Cases at First Detection with", scales::percent(Detect_Threshold_ForDate), "probability"))
  })
```

Row
-----------------------------------------------------------------------
### Detection by Disease for Different Hospital Coverage
```{r}
renderPlot({ggplot() + 
     geom_point(data=inner_join(
       MonteCarloData  %>% 
         filter(HospPCT==Coverage_rates[match(input$Coverage, Coverage_names)]),
       All_disease_mapping_table ) 
                %>% filter(DetectThreshold==input$Threshold),
                        aes(y=Cumulative_probability, x=Day, color=Disease), size=1) +
     labs(x="Day", y="Cumulative probability")+
     # xlim(0,100)+
     geom_smooth(data=inner_join(
       MonteCarloData  %>% 
         filter(HospPCT==Coverage_rates[match(input$Coverage, Coverage_names)]),
       All_disease_mapping_table ) %>%
         filter(DetectThreshold==input$Threshold),
                 formula=y ~ s(x, bs = "cs"), 
                 aes(y=Cumulative_probability, 
                     x=Day, group = Disease),
                 method="gam",color="black")+
     ggtitle(paste(input$Coverage, "Detection Threshold:",input$Threshold))
  })

```

Model Documentation
=======================================================================

Row
-----------------------------------------------------------------------
```{r test, child="Documentation.RMD", eval=TRUE, local=TRUE}
```
